import javalang
import secrets
import random
import json

from os import listdir
from os.path import isfile, join


def get_radom_var_name():
    """
    Generates a random variable name consisting of 8 lowercase letters.
    
    Returns:
        str: A string representing the generated variable name.
    """
    res_string = ''
    for x in range(8):
        res_string += random.choice('abcdefghijklmnopqrstuvwxyz')
    return res_string


def get_dead_for_condition():
    """
    Creates a for loop condition that will never execute because the condition is always false.
    
    Returns:
        str: A string representing the for loop condition.
    """
    var = get_radom_var_name()
    return "int "+var+" = 0; "+var+" < 0; "+var+"++"


def get_random_false_stmt():
    """
    Generates a boolean expression that will always evaluate to False.
    
    Returns:
        str: A string representing the boolean expression.
    """
    res = [random.choice(["True", "False"]) for x in range(10)]
    res.append("False")
    res_str = " and ".join(res)
    return res_str


def get_tree(data):
    """
    Parses the given Java code into an Abstract Syntax Tree (AST).
    
    Args:
        data (str): A string containing Java code.
    
    Returns:
        object: The root of the AST generated by parsing the code.
    """
    tokens = javalang.tokenizer.tokenize(data)
    parser = javalang.parser.Parser(tokens)
    tree = parser.parse_member_declaration()
    return tree


def verify_method_syntax(data):
    """
    Checks if the given Java method has correct syntax.
    
    Args:
        data (str): A string containing a Java method.
    
    Prints:
        A message indicating whether the syntax check passed or failed.
    """
    try:
        tokens = javalang.tokenizer.tokenize(data)
        parser = javalang.parser.Parser(tokens)
        tree = parser.parse_member_declaration()
        print("syantax check passed")
    except:
        print("syantax check failed")


def get_random_type_name_and_value_statment():
    """
    Generates a random variable declaration with an appropriate value based on the variable's type.
    
    Returns:
        str: A string representing the variable declaration statement.
    """
    datatype = random.choice(
        'byte,short,int,long,float,double,boolean,char,String'.split(','))
    var_name = get_radom_var_name()

    if datatype == "byte":
        var_value = get_random_int(-128, 127)
    elif datatype == "short":
        var_value = get_random_int(-10000, 10000)
    elif datatype == "boolean":
        var_value = random.choice(["True", "False"])
    elif datatype == "char":
        var_value = str(random.choice(
            'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z'.split(',')))
        var_value = '"'+var_value+'"'
    elif datatype == "String":
        var_value = str(get_radom_var_name())
        var_value = '"'+var_value+'"'
    else:
        var_value = get_random_int(-1000000000, 1000000000)

    mutant = str(var_name) + ' = ' + str(var_value)
    return mutant


def generate_file_name_list_file_from_dir(method_path):
    """
    Creates a text file containing a list of all filenames in the specified directory.
    
    Args:
        method_path (str): The path to the directory.
    
    Prints:
        A message indicating completion of the operation.
    """
    filenames = [f for f in listdir(
        method_path) if isfile(join(method_path, f))]
    with open(method_path+'\\'+'all_file_names.txt', 'w') as f:
        f.write(json.dumps(filenames))
    print("done")


def get_file_name_list(method_path):
    """
    Reads a list of filenames from a text file in the specified directory.
    
    Args:
        method_path (str): The path to the directory containing the text file.
    
    Returns:
        list: A list of filenames read from the file.
    """
    with open(method_path+'\\'+'all_file_names.txt') as f:
        data = json.load(f)
    return data


def get_random_int(min, max):
    """
    Generates a random integer between the specified minimum and maximum values.
    
    Args:
        min (int): The minimum value of the random integer.
        max (int): The maximum value of the random integer.
    
    Returns:
        int: A randomly generated integer within the specified range.
    """
    return random.randint(min, max)


def format_code_chuncks(code_chuncks):
    """
    Formats a list of code chunks by removing unnecessary spaces around punctuation.
    
    Args:
        code_chunks (list): A list of strings representing code chunks.
    
    Returns:
        list: The list of formatted code chunks.
    """
    for idx, c in enumerate(code_chuncks):
        c = c.replace(' . ', '.')
        c = c.replace(' ( ', '(')
        c = c.replace(' ) ', ')')
        c = c.replace(' ;', ';')
        c = c.replace('[ ]', '[]')
        code_chuncks[idx] = c
    return code_chuncks


def format_code(c):
    """
    Formats a single string of code by removing unnecessary spaces around punctuation.
    
    Args:
        c (str): A string representing a chunk of code.
    
    Returns:
        str: The formatted code string.
    """
    c = c.replace(' . ', '.')
    c = c.replace(' ( ', '(')
    c = c.replace(' ) ', ')')
    c = c.replace(' ;', ';')
    c = c.replace('[ ]', '[]')
    return c


def get_method_header(string):
    """
    Extracts the header of a method from a given string containing Java code.
    
    Args:
        string (str): A string containing Java code.
    
    Returns:
        str: The method header extracted from the code.
    """
    method_header = ''
    tree = get_tree(string)

    tokens = list(javalang.tokenizer.tokenize(string))

    chunck_start_poss = [s.position.column for s in tree.body]
    if len(chunck_start_poss) > 0:
        method_header = ' '.join([t.value for t in tokens
                                  if t.position.column < chunck_start_poss[0]])

    method_header = format_code_chuncks([method_header])[0]
    return method_header


def get_method_statement(string):
    """
    Extracts the statements of a method from a given string containing Java code.
    
    Args:
        string (str): A string containing Java code.
    
    Returns:
        list: A list of strings representing the method's statements.
    """
    code_chuncks = []
    tree = get_tree(string)
    tokens = list(javalang.tokenizer.tokenize(string))
    chunck_start_poss = [s.position.column for s in tree.body]

    if len(chunck_start_poss) > 1:
        for idx, statement in enumerate(chunck_start_poss[:-1]):
            statment = ' '.join([t.value for t in tokens
                                 if t.position.column >= chunck_start_poss[idx]
                                 and t.position.column < chunck_start_poss[idx+1]])
            code_chuncks.append(statment)

        last_statment = ' '.join([t.value for t in tokens
                                  if t.position.column >= chunck_start_poss[-1]][:-1])
        code_chuncks.append(last_statment)

    if len(chunck_start_poss) == 1:
        last_statment = ' '.join([t.value for t in tokens
                                  if t.position.column >= chunck_start_poss[0]][:-1])
        code_chuncks.append(last_statment)
    code_chuncks = format_code_chuncks(code_chuncks)
    return code_chuncks


def scan_tree(tree):
    """
    Prints the nodes of the given Abstract Syntax Tree (AST).
    
    Args:
        tree (object): The root of the AST to be scanned.
    """
    for path, node in tree:
        print("=======================")
        print(node)


def get_all_type(tree):
    """
    Retrieves all types from the given Abstract Syntax Tree (AST).
    
    Args:
        tree (object): The root of the AST.
    
    Returns:
        list: A list of all types found in the AST.
    """
    res_list=[]
    for path, node in tree.filter(javalang.tree.ReferenceType):
        if node.name != None:
            res_list.append(node.name)
    return list(set(res_list))


def scan_local_vars(tree):
    """
    Prints the names and types of local variables found in the given Abstract Syntax Tree (AST).
    
    Args:
        tree (object): The root of the AST.
    """
    for path, node in tree.filter(javalang.tree.LocalVariableDeclaration):
        print("name=========type=============")
        print(node.declarators[0].name, "\t", node.type.name)


def get_local_vars(tree):
    """
    Retrieves a list of local variables from the given Abstract Syntax Tree (AST).
    
    Args:
        tree (object): The root of the AST.
    
    Returns:
        list: A list of local variables, each represented as a [name, type] pair.
    """
    var_list = []
    for path, node in tree.filter(javalang.tree.LocalVariableDeclaration):
        var_list.append([node.declarators[0].name, node.type.name])
    return var_list


def get_local_assignments(tree):
    """
    Retrieves a list of local variable assignments from the given Abstract Syntax Tree (AST).
    
    Args:
        tree (object): The root of the AST.
    
    Returns:
        list: A list of local variable assignments, each represented as a [name, type] pair.
    """
    var_list = []
    for path, node in tree.filter(javalang.tree.Assignment):
        var_list.append([node.declarators[0].name, node.type.name])
    return var_list


def get_branch_if_else_mutant():
    """
    Generates a mutant if-else branch with a random type name and value statement, where the if condition is always false.
    
    Returns:
        str: A string representing the mutant if-else branch.
    """
    mutant = get_random_type_name_and_value_statment() + ' if '+get_random_false_stmt() + ' else ' + str(get_random_int(-1000000000, 1000000000))
    return mutant


def get_branch_if_mutant():
    """
    Generates a mutant if branch with a random type name and value statement, where the if condition is always false.
    
    Returns:
        str: A string representing the mutant if branch.
    """
    mutant = 'if '+get_random_false_stmt()+': ' + \
        get_random_type_name_and_value_statment()
    return mutant


def get_branch_while_mutant():
    """
    Generates a mutant while loop with a random type name and value statement, where the while condition is always false.
    
    Returns:
        str: A string representing the mutant while loop.
    """
    mutant = 'while '+get_random_false_stmt()+': ' + \
        get_random_type_name_and_value_statment()
    return mutant


def get_branch_for_mutant():
    """
    Generates a mutant for loop that will never execute because the range is zero.
    
    Returns:
        str: A string representing the mutant for loop.
    """
    var = get_radom_var_name()
    mutant = 'for ' + var + ' in range(0): ' + get_random_type_name_and_value_statment()
    return mutant


